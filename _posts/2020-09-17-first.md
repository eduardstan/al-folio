---
layout: distill
title: A gentle introduction to (Temporal) Logics
description: A simple introduction to the field of mathematical logic.
date: 2020-08-17 16:46:00+0200
comments: true
---

## Introduction

Every formal science needs a language to be able for expressing results and communicate information with others in a comprehensible way. Logicâ€™s purpose is to study this formal representation without ambiguity in terms of a formal language, which provides to humans those crucial mathematical mechanisms to securely control reasonings. It is obvious that there is no universal logical language to represent every science. <!---Artificial Intelligence (AI) is among the most representative witnesses that uses logic to, e.g., represent knowledge.--->

The goal is to present a journey through a possible set of formal languages (actively) used in Artificial Intelligence (AI).

## First Order Logic

*Predicate logic* or, more commonly, *First Order Logic* ($\mathsf{FOL}$) is an excellent departure for our survey. In a matter of fact, its important structural properties gives us enough formal "ingredients" to express classes of problems.

The alphabet $\Sigma$ over $\mathsf{FOL}$ is formed by:

* logical *connectives*: $\bot, \top, \neg, \land, \lor, \to$;
* *quantifiers*: $\forall, \exists$;
* a set $\mathcal{C}$ of *constant* symbols: $a,b,c,d,\ldots$;
* an infinite set $\mathcal{V}$ of *variable* symbols: $u,v,w,x,y,\ldots$;
* a set $\mathcal{F}$ of *function* symbols: $f,g,h,\ldots$;
* a set $\mathcal{P}$ of *predicate* symbols: $P,Q,R,\ldots$.

Each predicate symbol and each function symbol comes with an *arity*, i.e., the number of arguments that expects. Constants can be thought of as $0$-arity functions which does not take any argument, therefore constants live in the set $\mathcal{F}$ together with the true functions which do take arguments<d-cite></d-cite>; $0$-arity functions are also called *nullary* functions.

In computer science, the notion of term is widely used in an implicit way. For instance, an arithmetic expression is a term obtained applying (arithmetical) operators to some operands. Therefore, the set of *terms* $\mathcal{T}$ of the $\mathsf{FOL}$ language is defined inductively as:

$$t ::= x \mid c \mid f(t_1,\ldots,t_n),$$

where $x$ ranges over the set of variables $\mathcal{V}$, $c$ over nullary function symbols in $\mathcal{F}$, and $f$ over those elements of $\mathcal{F}$ with arity $n > 0$.

Well formed formulas over $\mathsf{FOL}$ are generated by the following grammar:

$$\varphi ::= P(t_1,\ldots,t_n) \mid \neg \varphi \mid \varphi \lor \varphi \mid \exists x (\varphi),$$

where $P \in \mathcal{P}$ is a predicate symbol of arity $n \geq 1$, $t_i$ are terms over $\mathcal{F}$ and $x \in \mathcal{V}$ is a variable symbol. The remaining connectives are derived from the others as:

* $\bot \equiv \neg (\neg \varphi \lor \varphi)$;
* $\top \equiv \neg \bot$;
* $\varphi_1 \land \varphi_2 \equiv \neg (\neg \varphi_1 \lor \neg \varphi_2)$;
* $\varphi_1 \to \varphi_2 \equiv \neg \varphi_1 \lor \varphi_2$;
* $\forall x (\varphi) \equiv \neg \exists x (\neg \varphi)$.

$\mathsf{FOL}$ is much more expressive than other logics presented here. As a matter of fact, in order to define its semantics, *structures* are build with a set $\mathcal{D}$ (the *domain*) together with a collection of functions and *relations* over the domain. A structure for a language is called interpretation. Formally, an *interpretation* $\mathcal{I}$ of the pair $(\mathcal{F},\mathcal{P})$ consists in the following:

* a non-empty set $\mathcal{D}$ representing the domain of concrete values;
* for each $c \in \mathcal{C}$, a concrete element $c^{\mathcal{I}}$ of $\mathcal{D}$;
* for each $f \in \mathcal{F}$ with arity $n > 0$, a concrete function $f^{\mathcal{I}}: \mathcal{D}^n \to \mathcal{D}$;
* for each $P \in \mathcal{P}$ with arity $n > 0$, a subset $P^{\mathcal{I}} \subseteq \mathcal{D}^n$,

where $c, f$ and $P$ are just constant, function and predicate symbols, and $c^{\mathcal{I}}, f^{\mathcal{I}}$ and $P^{\mathcal{I}}$ are concrete constant, function and relation, respectively.

For each term $t \in \mathcal{T}$, we need a function $\sigma: \mathcal{T} \to \mathcal{D}$, called *state*, that assigns, inductively, to each term $t$ a value $\sigma(t) \in \mathcal{D}$, defined as follows:

* if $t$ is a variable $x$, then $\sigma(t) = \sigma(x)$;
* if $t$ is a constant $c$, then $\sigma(t) = c^{\mathcal{I}}$;
* if $t$ is a term like $f(t_1,\ldots,t_n)$, then $\sigma(t) = f^{\mathcal{I}}(\sigma(t_1), \ldots, \sigma(t_n))$.

Given an interpretation $\mathcal{I}$ with its state $\sigma$, we are able to define the semantics of $\mathsf{FOL}$'s language as follows:

* $\mathcal{I},\sigma \models P(t_1,\ldots,t_n)$ iff $(\sigma(t_1),\ldots,\sigma(t_n)) \in P^{\mathcal{I}}$ meaning that the concrete values $(d_1,\ldots,d_n) \in \mathcal{D}^n$ are computed by replacing all terms with their values according to $\sigma$;
* $\mathcal{I},\sigma \models \neg \varphi$ iff $\mathcal{I},\sigma \not\models \varphi$;
* $\mathcal{I},\sigma \models \varphi_1 \lor \varphi_2$ iff $\mathcal{I},\sigma \models \varphi_1$ or $\mathcal{I},\sigma \models \varphi_2$;
* $\mathcal{I},\sigma \models \exists x (\varphi)$ iff $\mathcal{I},\sigma \models \varphi$ for some $d \in \mathcal{D}$ such that $\sigma(x) = d$.

We say that a formula $\varphi$ is *satisfiable* if there exists a true interpretation $\mathcal{I}$ along with its state $\sigma$; in this case, $\mathcal{I}$ is called *model* $M$ and we write $\mathcal{I},\sigma \models \varphi$ or $M,\sigma \models \varphi$. If $M,\sigma \models \varphi$ holds, we say that $\varphi$ computes to $\top$ in the model $M$ with respect to its state $\sigma$. A formula $\varphi$ is *unsatisfiable*, denoted by $\not\models \varphi$, if there is no way to give a true interpretation over it. A formula $\varphi$ is a *tautology* (or *validity*) if every interpretation is a model or if $\neg \varphi$ is unsatisfiable. Moreover, two formulas $\varphi_1$ and $\varphi_2$ are said to be *semantically equivalent*, denoted by $\varphi_1 \equiv \varphi_2$, if and only if, for all interpretations $\mathcal{I}$, it turns out that $\mathcal{I}(\varphi_1) = \mathcal{I}(\varphi_2)$.

In order to take a closer look to the inherent difficulty of $\mathsf{FOL}$, we choose the SAT problem as emblematic. It turns out that the SAT problem gives us a good measure of the complexity of a given problem. There are good news and bad news: the SAT problem for the $\mathsf{FOL}$ is not decidable <d-cite>Sisper</d-cite>. On the other hand, the good news are that several problems can be transformed into SAT problems. For instance, the *deduction problem*, that is given the premises $\varphi_1 \land \varphi_2 \land \ldots \land \varphi_n$ the goal is to conclude the consequent $\varphi_{n+1}$, can be translated into a SAT problem verifying if the formula $\varphi \equiv \varphi_1 \land \varphi_2 \land \ldots \land \varphi_n \land \neg \varphi_{n+1}$ has a true interpretation and if it does, clearly, we cannot conclude $\varphi_{n+1}$ (from the premises).

## Propositional Logic

The problem with $\mathsf{FOL}$ is that thanks to its expressive power we can capture a class of problems that is too large. Because of the undecidable nature, we are forced to limit its expressiveness in order to obtain languages that are useful from the practical point of view.

*Propositional Logic* ($\mathsf{PL}$) is one of these candidates which has interesting properties. First, its SAT problem is known to be decidable and it is $NP$-complete <d-cite>Cook</d-cite>; thus, we can build terminating programs for it. Second, it is strictly less expressive than $\mathsf{FOL}$, denoted here as:

$$\mathsf{PL} \prec \mathsf{FOL}.$$ 

This presentation is different from those found in the literature (see, e.g., <d-cite>HR04</d-cite>) in which, normally, the journey starts with $\mathsf{PL}$ studying its syntactic and semantic structures ending with its expressiveness limits, and, after these limits are given, later $\mathsf{FOL}$ is the subject of the discourse. Limiting the expressive power of an undecidable logic, such as $\mathsf{FOL}$, gives us better computational behaviors and this is the case, for example, of $\mathsf{PL}$.

The alphabet $\Sigma$ of $\mathsf{PL}$ language is formed by:

* logical connectives: $\bot, \top, \neg, \land, \lor, \to$;
* a set $\mathcal{AP}$ of *atomic propositions*: $p,q,r,t,\ldots$.

Well formed formulas are generated by the following grammar:

$$\varphi ::= p \mid \neg \varphi \mid \varphi \lor \varphi.$$

The remaining connectives are derived as before.

The investigation of $\mathsf{PL}$ is focused on propositions, that is a concept of truth value. These propositions can be atoms or *composition* of atoms. An atom (or atomic formula) are the most simple well formed formulas of the logic with no deeper structure, meanwhile the more complex well formed formulas are generated from simple atoms; for instance, atoms in $\mathsf{FOL}$ are formulas of the form $P(t_1,\ldots,t_n)$ for $P$ a predicate and $t_1,\ldots,t_n$ terms, and composition of formulas are those obtained, recursively, applying logical connectives and/or quantifiers to atoms.

In this formal language, an interpretation is a function $\nu : \mathcal{AP} \to \\{\top,\bot\\}$, that assigns truth values to each atomic formula. If an interpretation $\nu$ is a model $M$ for a formula $\varphi$, then we write $M \models \varphi$. 

The semantics of $\mathsf{PL}$ is defined by structural induction as:
* $M \models p$ iff $p \in M$;
* $M \models \neg \varphi$ iff $M \not\models \varphi$;
* $M \models \varphi_1 \lor \varphi_2$ iff $M \models \varphi_1$ or $M \models \varphi_2$.

## Modal Logic

*Modal Logic* ($\mathsf{ML}$) is used in computer science, for example, to formalize reasoning about the way programs behave and to express dynamical properties of transition between states in a transition system (i.e., a directed graph).

The alphabet $\Sigma$ of $\mathsf{ML}$ language is formed by:

* logical connectives: $\bot, \top, \neg, \land, \lor, \to$;
* unary *modal operators*: $\Diamond, \Box$;
* a set $\mathcal{AP}$ of *atomic propositions*: $p,q,r,t,\ldots$.

Well formed formulas are generated by the following grammar:

$$\varphi ::= p \mid \neg \varphi \mid \varphi \lor \varphi \mid \Diamond \varphi.$$

The remaining connectives are derived as before with particular attention to:

$$\Box \varphi \equiv \neg \Diamond \neg \varphi,$$

which stands for *"what is necessarily true is not possibly not true"*. Moreover, $\Box \varphi$ and $\Diamond \varphi$ in terms of computer programs could say that *"$\varphi$ will be true after every execution of the program"* and *"$\varphi$ will be true after some execution of the program"*, respectively.

$\mathsf{ML}$ is strictly less expressive than $\mathsf{FOL}$, but strictly more expressive than $\mathsf{PL}$:

$$\mathsf{PL} \prec \mathsf{ML} \prec \mathsf{FOL}.$$

The semantics for $\mathsf{ML}$ are defined in terms of *Kripke frames* and *Kripke models* <d-cite>Kripke</d-cite>. Formally, a Kripke frame is a pair $\langle \mathcal{W}, \mathcal{R} \rangle$, where $\mathcal{W}$ is a non-empty set of possible *worlds* and $\mathcal{R} \subseteq \mathcal{W} \times \mathcal{W}$ is an *accessibility relation* between possible worlds. A Kripke model $M$ is a structure $\langle \mathcal{W},\mathcal{R},V \rangle$, where $\langle \mathcal{W}, \mathcal{R} \rangle$ is a Kripke frame and $V : \mathcal{AP} \to 2^{\mathcal{W}}$ is a *valuation function* assigning to every atomic proposition the set of possible worlds where it is true; $2^{\mathcal{W}}$ is the *power set* of $\mathcal{W}$ also denoted by $\mathcal{P}(\mathcal{W})$. In this journey, we concern (only) on the logic $\mathsf{K}$ of all Kripke models whose SAT problem is known to be $PSpace$-complete<d-cite>Ladner</d-cite>. The truth of a formula $\varphi$ at a possible world $w$ in a Kripke model $M = \langle \mathcal{W},\mathcal{R},V \rangle$ is defined by structural induction as follows:

* $M,w \models p$ iff $w \in V(p)$, $\forall p \in \mathcal{AP}$;
* $M,w \models \neg \varphi$ iff $M,w \not\models \varphi$;
* $M,w \models \varphi_1 \lor \varphi_2$ iff $M,w \models \varphi_1$ or $M,w \models \varphi_2$;
* $M,w \models \Diamond \varphi$ iff $M,u \models \varphi$ for some $u \in \mathcal{W}$ such that $(w,u) \in \mathcal{R}$.

Respectively, $M,w \models \Box \varphi$ iff $M,u \models \varphi$ for every $u \in \mathcal{W}$ such that $(w,u) \in \mathcal{R}$.

We mentioned that we are interested only on logic $\mathsf{K}$ of all Kripke models, although other modal logics (e.g., $\mathsf{T}, \mathsf{D}, \mathsf{B}, \mathsf{K4}, \mathsf{S4}, \mathsf{S5})$ can be defined semantically by restricting the class of Kripke frames in which modal formulas are interpreted.























