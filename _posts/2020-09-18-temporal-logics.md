---
layout: distill
title: A gentle introduction to (Temporal) Logics
description: A simple introduction to the field of mathematical logic.
date: 2020-08-18-temporal-logics.bib
comments: true

authors:
  - name: Stan, I.E.
    url:
    affiliations:
      name: Department of Mathematics and Computer Science, University of Ferrara, and Department of Mathematical, Physical, and Computer Sciences, University of Parma

bibliography: 2020/temporal-logics.bib

_styles: >
  .fake-img {
    background: #bbb;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 0px 4px rgba(0, 0, 0, 0.1);
    margin-bottom: 12px;
  }
  .fake-img p {
    font-family: monospace;
    color: white;
    text-align: left;
    margin: 12px 0;
    text-align: center;
    font-size: 16px;
  }
---

# Table of Contents
1. [Introduction](#introduction)
2. [First Order Logic](#first-order-logic)
3. [Propositional Logic](#propositional-logic)
4. [Modal Logic](#modal-logic)
5. [Temporal Logic](#temporal-logic)
6. [Interval Temporal Logic](#interval-temporal-logic)
7. [Conclusions](#conclusions)

## Introduction

Every formal science needs a language to be able for expressing results and communicate information with others in a comprehensible way. Logicâ€™s purpose is to study this formal representation without ambiguity in terms of a formal language, which provides to humans those crucial mathematical mechanisms to securely control reasonings. It is obvious that there is no universal logical language to represent every science. <!---Artificial Intelligence (AI) is among the most representative witnesses that uses logic to, e.g., represent knowledge.--->

The goal is to present a journey through a possible set of formal languages (actively) used in Artificial Intelligence (AI).

## First Order Logic

*Predicate logic* or, more commonly, *First Order Logic* ($\mathsf{FOL}$) is an excellent departure for our survey. In a matter of fact, its important structural properties gives us enough formal "ingredients" to express classes of problems.

The alphabet $\Sigma$ over $\mathsf{FOL}$ is formed by:

* logical *connectives*: $\bot, \top, \neg, \land, \lor, \to$;
* *quantifiers*: $\forall, \exists$;
* a set $\mathcal{C}$ of *constant* symbols: $a,b,c,d,\ldots$;
* an infinite set $\mathcal{V}$ of *variable* symbols: $u,v,w,x,y,\ldots$;
* a set $\mathcal{F}$ of *function* symbols: $f,g,h,\ldots$;
* a set $\mathcal{P}$ of *predicate* symbols: $P,Q,R,\ldots$.

Each predicate symbol and each function symbol comes with an *arity*, i.e., the number of arguments that expects. Constants can be thought of as $0$-arity functions which does not take any argument, therefore constants live in the set $\mathcal{F}$ together with the true functions which do take arguments<d-cite key="lics_huth_ryan"></d-cite>; $0$-arity functions are also called *nullary* functions. 

In computer science, the notion of term is widely used in an implicit way. For instance, an arithmetic expression is a term obtained applying (arithmetical) operators to some operands. Therefore, the set of *terms* $\mathcal{T}$ of the $\mathsf{FOL}$ language is defined inductively as:

$$t ::= x \mid c \mid f(t_1,\ldots,t_n),$$

where $x$ ranges over the set of variables $\mathcal{V}$, $c$ over nullary function symbols in $\mathcal{F}$, and $f$ over those elements of $\mathcal{F}$ with arity $n > 0$.

Well formed formulas over $\mathsf{FOL}$ are generated by the following grammar:

$$\varphi ::= P(t_1,\ldots,t_n) \mid \neg \varphi \mid \varphi \lor \varphi \mid \exists x (\varphi),$$

where $P \in \mathcal{P}$ is a predicate symbol of arity $n \geq 1$, $t_i$ are terms over $\mathcal{F}$ and $x \in \mathcal{V}$ is a variable symbol. The remaining connectives are derived from the others as:

* $\bot \equiv \neg (\neg \varphi \lor \varphi)$;
* $\top \equiv \neg \bot$;
* $\varphi_1 \land \varphi_2 \equiv \neg (\neg \varphi_1 \lor \neg \varphi_2)$;
* $\varphi_1 \to \varphi_2 \equiv \neg \varphi_1 \lor \varphi_2$;
* $\forall x (\varphi) \equiv \neg \exists x (\neg \varphi)$.

$\mathsf{FOL}$ is much more expressive than other logics presented here. As a matter of fact, in order to define its semantics, *structures* are build with a set $\mathcal{D}$ (the *domain*) together with a collection of functions and *relations* over the domain. A structure for a language is called interpretation. Formally, an *interpretation* $\mathcal{I}$ of the pair $(\mathcal{F},\mathcal{P})$ consists in the following:

* a non-empty set $\mathcal{D}$ representing the domain of concrete values;
* for each $c \in \mathcal{C}$, a concrete element $c^{\mathcal{I}}$ of $\mathcal{D}$;
* for each $f \in \mathcal{F}$ with arity $n > 0$, a concrete function $f^{\mathcal{I}}: \mathcal{D}^n \to \mathcal{D}$;
* for each $P \in \mathcal{P}$ with arity $n > 0$, a subset $P^{\mathcal{I}} \subseteq \mathcal{D}^n$,

where $c, f$ and $P$ are just constant, function and predicate symbols, and $c^{\mathcal{I}}, f^{\mathcal{I}}$ and $P^{\mathcal{I}}$ are concrete constant, function and relation, respectively.

For each term $t \in \mathcal{T}$, we need a function $\sigma: \mathcal{T} \to \mathcal{D}$, called *state*, that assigns, inductively, to each term $t$ a value $\sigma(t) \in \mathcal{D}$, defined as follows:

* if $t$ is a variable $x$, then $\sigma(t) = \sigma(x)$;
* if $t$ is a constant $c$, then $\sigma(t) = c^{\mathcal{I}}$;
* if $t$ is a term like $f(t_1,\ldots,t_n)$, then $\sigma(t) = f^{\mathcal{I}}(\sigma(t_1), \ldots, \sigma(t_n))$.

Given an interpretation $\mathcal{I}$ with its state $\sigma$, we are able to define the semantics of $\mathsf{FOL}$'s language as follows:

* $\mathcal{I},\sigma \models P(t_1,\ldots,t_n)$ iff $(\sigma(t_1),\ldots,\sigma(t_n)) \in P^{\mathcal{I}}$ meaning that the concrete values $(d_1,\ldots,d_n) \in \mathcal{D}^n$ are computed by replacing all terms with their values according to $\sigma$;
* $\mathcal{I},\sigma \models \neg \varphi$ iff $\mathcal{I},\sigma \not\models \varphi$;
* $\mathcal{I},\sigma \models \varphi_1 \lor \varphi_2$ iff $\mathcal{I},\sigma \models \varphi_1$ or $\mathcal{I},\sigma \models \varphi_2$;
* $\mathcal{I},\sigma \models \exists x (\varphi)$ iff $\mathcal{I},\sigma \models \varphi$ for some $d \in \mathcal{D}$ such that $\sigma(x) = d$.

We say that a formula $\varphi$ is *satisfiable* if there exists a true interpretation $\mathcal{I}$ along with its state $\sigma$; in this case, $\mathcal{I}$ is called *model* $M$ and we write $\mathcal{I},\sigma \models \varphi$ or $M,\sigma \models \varphi$. If $M,\sigma \models \varphi$ holds, we say that $\varphi$ computes to $\top$ in the model $M$ with respect to its state $\sigma$. A formula $\varphi$ is *unsatisfiable*, denoted by $\not\models \varphi$, if there is no way to give a true interpretation over it. A formula $\varphi$ is a *tautology* (or *validity*) if every interpretation is a model or if $\neg \varphi$ is unsatisfiable. Moreover, two formulas $\varphi_1$ and $\varphi_2$ are said to be *semantically equivalent*, denoted by $\varphi_1 \equiv \varphi_2$, if and only if, for all interpretations $\mathcal{I}$, it turns out that $\mathcal{I}(\varphi_1) = \mathcal{I}(\varphi_2)$.

In order to take a closer look to the inherent difficulty of $\mathsf{FOL}$, we choose the SAT problem as emblematic. It turns out that the SAT problem gives us a good measure of the complexity of a given problem. There are good news and bad news: the SAT problem for the $\mathsf{FOL}$ is not decidable <d-cite key="sisper_computation"></d-cite>. On the other hand, the good news are that several problems can be transformed into SAT problems. For instance, the *deduction problem*, that is given the premises $\varphi_1 \land \varphi_2 \land \ldots \land \varphi_n$ the goal is to conclude the consequent $\varphi_{n+1}$, can be translated into a SAT problem verifying if the formula $\varphi \equiv \varphi_1 \land \varphi_2 \land \ldots \land \varphi_n \land \neg \varphi_{n+1}$ has a true interpretation and if it does, clearly, we cannot conclude $\varphi_{n+1}$ (from the premises).

## Propositional Logic

The problem with $\mathsf{FOL}$ is that thanks to its expressive power we can capture a class of problems that is too large. Because of the undecidable nature, we are forced to limit its expressiveness in order to obtain languages that are useful from the practical point of view.

*Propositional Logic* ($\mathsf{PL}$) is one of these candidates which has interesting properties. First, its SAT problem is known to be decidable and it is $NP$-complete <d-cite key="Cook:1971:CTP:800157.805047"></d-cite>; thus, we can build terminating programs for it. Second, it is strictly less expressive than $\mathsf{FOL}$, denoted here as:

$$\mathsf{PL} \prec \mathsf{FOL}.$$ 

This presentation is different from those found in the literature (see, e.g., <d-cite key="lics_huth_ryan"></d-cite>) in which, normally, the journey starts with $\mathsf{PL}$ studying its syntactic and semantic structures ending with its expressiveness limits, and, after these limits are given, later $\mathsf{FOL}$ is the subject of the discourse. Limiting the expressive power of an undecidable logic, such as $\mathsf{FOL}$, gives us better computational behaviors and this is the case, for example, of $\mathsf{PL}$.

The alphabet $\Sigma$ of $\mathsf{PL}$ language is formed by:

* logical connectives: $\bot, \top, \neg, \land, \lor, \to$;
* a set $\mathcal{AP}$ of *atomic propositions*: $p,q,r,t,\ldots$.

Well formed formulas are generated by the following grammar:

$$\varphi ::= p \mid \neg \varphi \mid \varphi \lor \varphi.$$

The remaining connectives are derived as before.

The investigation of $\mathsf{PL}$ is focused on propositions, that is a concept of truth value. These propositions can be atoms or *composition* of atoms. An atom (or atomic formula) are the most simple well formed formulas of the logic with no deeper structure, meanwhile the more complex well formed formulas are generated from simple atoms; for instance, atoms in $\mathsf{FOL}$ are formulas of the form $P(t_1,\ldots,t_n)$ for $P$ a predicate and $t_1,\ldots,t_n$ terms, and composition of formulas are those obtained, recursively, applying logical connectives and/or quantifiers to atoms.

In this formal language, an interpretation is a function $\nu : \mathcal{AP} \to \\{\top,\bot\\}$, that assigns truth values to each atomic formula. If an interpretation $\nu$ is a model $M$ for a formula $\varphi$, then we write $M \models \varphi$. 

The semantics of $\mathsf{PL}$ is defined by structural induction as:
* $M \models p$ iff $p \in M$;
* $M \models \neg \varphi$ iff $M \not\models \varphi$;
* $M \models \varphi_1 \lor \varphi_2$ iff $M \models \varphi_1$ or $M \models \varphi_2$.

## Modal Logic

*Modal Logic* ($\mathsf{ML}$) is used in computer science, for example, to formalize reasoning about the way programs behave and to express dynamical properties of transition between states in a transition system (i.e., a labelled directed graph).

The alphabet $\Sigma$ of $\mathsf{ML}$ language is formed by:

* logical connectives: $\bot, \top, \neg, \land, \lor, \to$;
* unary *modal operators*: $\Diamond, \Box$;
* a set $\mathcal{AP}$ of *atomic propositions*: $p,q,r,t,\ldots$.

Well formed formulas are generated by the following grammar:

$$\varphi ::= p \mid \neg \varphi \mid \varphi \lor \varphi \mid \Diamond \varphi.$$

The remaining connectives are derived as before with particular attention to:

* $\Box \varphi \equiv \neg \Diamond \neg \varphi,$

which stands for *"what is necessarily true is not possibly not true"*. Moreover, $\Box \varphi$ and $\Diamond \varphi$ in terms of computer programs could say that *"$\varphi$ will be true after every execution of the program"* and *"$\varphi$ will be true after some execution of the program"*, respectively.

$\mathsf{ML}$ is strictly less expressive than $\mathsf{FOL}$, but strictly more expressive than $\mathsf{PL}$:

$$\mathsf{PL} \prec \mathsf{ML} \prec \mathsf{FOL}.$$

The semantics for $\mathsf{ML}$ are defined in terms of *Kripke frames* and *Kripke models* <d-cite key="kripke"></d-cite>. Formally, a Kripke frame is a pair $\langle \mathcal{W}, \mathcal{R} \rangle$, where $\mathcal{W}$ is a non-empty set of possible *worlds* and $\mathcal{R} \subseteq \mathcal{W} \times \mathcal{W}$ is an *accessibility relation* between possible worlds. A Kripke model $M$ is a structure $\langle \mathcal{W},\mathcal{R},V \rangle$, where $\langle \mathcal{W}, \mathcal{R} \rangle$ is a Kripke frame and $V : \mathcal{AP} \to 2^{\mathcal{W}}$ is a *valuation function* assigning to every atomic proposition the set of possible worlds where it is true; $2^{\mathcal{W}}$ is the *power set* of $\mathcal{W}$ also denoted by $\wp(\mathcal{W})$. In this journey, we concern (only) on the logic $\mathsf{K}$ of all Kripke models whose SAT problem is known to be $PSpace$-complete<d-cite key="DBLP:journals/siamcomp/Ladner77"></d-cite>. The truth of a formula $\varphi$ at a possible world $w$ in a Kripke model $M = \langle \mathcal{W},\mathcal{R},V \rangle$ is defined by structural induction as follows:

* $M,w \models p$ iff $w \in V(p)$, $\forall p \in \mathcal{AP}$;
* $M,w \models \neg \varphi$ iff $M,w \not\models \varphi$;
* $M,w \models \varphi_1 \lor \varphi_2$ iff $M,w \models \varphi_1$ or $M,w \models \varphi_2$;
* $M,w \models \Diamond \varphi$ iff $M,u \models \varphi$ for some $u \in \mathcal{W}$ such that $(w,u) \in \mathcal{R}$.

Respectively, $M,w \models \Box \varphi$ iff $M,u \models \varphi$ for every $u \in \mathcal{W}$ such that $(w,u) \in \mathcal{R}$.

We mentioned that we are interested only on logic $\mathsf{K}$ of all Kripke models, although other modal logics (e.g., $\mathsf{T}, \mathsf{D}, \mathsf{B}, \mathsf{K4}, \mathsf{S4}, \mathsf{S5})$ can be defined semantically by restricting the class of Kripke frames in which modal formulas are interpreted.

## Temporal Logic

The typical approach of classical logic adopts a static fashion reasoning within a single fixed world. For example, a proposition such that *"it is Sunday"* must be either true or false. *Temporal Logic* is used as formalism to define the semantics of temporal expressions in natural language, as a language for encoding temporal knowledge in Artificial Intelligence <d-cite key="sep-logic-temporal"></d-cite>. Most systems are dynamic in their domain, therefore we need the granular properties of time.

Time can be thought as a set of paths (a sequence of time instances) or as a (rooted) tree. An emblematic example of temporal logic based on the former interpretation is *Linear Temporal Logic* ($\mathsf{LTL}$). Similarly, the most prominent example of temporal logic following the latter structure is *Computation Tree Logic* ($\mathsf{CTL}$).In this section, we do not present $\mathsf{CTL}$ because is not interesting for the purpose of this presentation, but we do present a particular type of $\mathsf{LTL}$, namely $\mathsf{LTL}_{F,P}$ with *future* and *past* whose SAT problem is $NP$-complete <d-cite key="pltl_emerson"></d-cite>. For simplicity, in the entire section we denote it with $\mathsf{LTL}$.

$\mathsf{LTL}$ is characterized by featuring two modalities that can be seen as two specific interpretations of the generic modalities $\Diamond$ and $\blacklozenge$, and are usually symbolized with the symbols $F$ and $P$ representing the concepts of future and past, respectively.

The $\mathsf{LTL}$ syntax is based on:

* logical connectives: $\bot, \top, \neg, \land, \lor, \to$;
* unary *modal operators*: $F, G, P, H$;
* a set $\mathcal{AP}$ of *atomic propositions*: $p,q,r,t,\ldots$.

Well formed formulas are generated by the following grammar:

$$\varphi ::= p \mid \neg \varphi \mid \varphi \lor \varphi \mid F \varphi \mid P \varphi.$$

The remaining connectives are derived as before with particular attention to:

* $G \varphi \equiv \neg F \neg \varphi$,

which stands for *"it will always (in the future) be the case that $\varphi$"*, and to:

* $H \varphi \equiv \neg P \neg \varphi$,

which stands for *"it has always (in the past) been the case that $\varphi$"*.

With this new syntax it should be clear that $\mathsf{LTL}$ is strictly less expressive than $\mathsf{FOL}$, but strictly more expressive than $\mathsf{ML}$:

$$\mathsf{PL} \prec \mathsf{ML} \prec \mathsf{LTL} \prec \mathsf{FOL}.$$

In order to define the semantics, we consider the same notation as for $\mathsf{ML}$ of Kripke frames and Kripke models. The primitive entities are *time instants* and, therefore, the basic relationship between them are the equality and the successor, denoted with the function $succ()$; the operators $F$ and $P$ are based on the transitive closure of $succ()$, normally denoted by $<$. Meanwhile, the domain $\mathcal{W}$ is isomorphic to the set of natural numbers $\mathbb{N}$. Thus, the temporal frame, expressed in terms of Kripke frames, for $\mathsf{LTL}$ is a pair $\langle \mathbb{N}, < \rangle$, and the temporal model, expressed in terms of Kripke models, is a triple $\langle \mathbb{N}, <, V \rangle$, where the valuation $V$ assigns to every $p \in \mathcal{AP}$ a set of time instants $V(p) \subseteq \mathbb{N}$ at which $p$ is declared true. The truth at an instant $t \in \mathbb{N}$ in a model $M = \langle \mathbb{N}, <, V \rangle$, as in $\mathsf{ML}$, is defined as:

* $M,t \models p$ iff $t \in V(p)$, $\forall p \in \mathcal{AP}$;
* $M,t \models \neg \varphi$ iff $M,t \not\models \varphi$;
* $M,t \models \varphi_1 \lor \varphi_2$ iff $M,t \models \varphi_1$ or $M,t \models \varphi_2$;
* $M,t \models F \varphi$ iff $M,s \models \varphi$ for some $s \in \mathbb{N}$ such that $t < s$;
* $M,t \models P \varphi$ iff $M,s \models \varphi$ for some $s \in \mathbb{N}$ such that $s < t$.

## Interval Temporal Logic

In the previous section we discussed about temporal reasoning based on time instants, namely point-based temporal logic. However, time points cannot properly reason about events that have an intrinsic duration. Thus, in this section we present a different approach concerning the logical communities.

*Interval Temporal Logic* ($\mathsf{ITL}$) takes as primitive ontological entities *time intervals* (or *periods*), rather than points. The context of interval-based logics is still "young", meaning that the scientific community is actively investing resources in studying these formalisms. For this reason, we do not have a proper representative of such class of logics, as we have for other logics (previously presented). However, Halpern and Shoham in <d-cite key="interval_modal_logic"></d-cite> presented the *Halpern-Shoham Interval (Multi-)Modal Logic*, hereafter $\mathsf{HS}$ for short, among with its undecidable result over many classes of linearly ordered sets. The distinguishing elegance and expressive power of $\mathsf{HS}$ have attracted the attention of modal and temporal logic communities, and, therefore, we take $\mathsf{HS}$ asrepresentative element of such class of logics.

Given a strict (i.e., irreflexive) linearly ordered set $\mathbb{D} = \langle \mathcal{D}, < \rangle$, an *interval* over $\mathbb{D}$ is an ordered pair $[x,y]$ such that $x,y \in \mathcal{D}$ and $x \leq y$. If $x=y$ then the interval is called *point interval*; otherwise, it is called a *proper (strict) interval*. An *interval structure* is a pair $\langle \mathbb{D}, \mathbb{I}(\mathbb{D}) \rangle$, where $\mathbb{I}(\mathbb{D})$ is the set of all *strict intervals*.

$\mathsf{HS}$ has its roots in Allen's Interval Algebra <d-cite key="allen83"></d-cite>: modal operators in $\mathsf{HS}$ can be mapped one-by-one over Allen's Interval Relations, often called Allen's Relations. The middle column of the following figure represents a sketch of such binary relations over strict semantics: $R_L$ (*later than*), $R_A$ (*meets/after than*), $R_O$ (*overlaps*), $R_E$ (*ends/finishes*), $R_D$ (*during*), $R_B$ (*begins/starts*) and their inverses, that are, $R_{\overline{L}}$ (*before*), $R_{\overline{A}}$ (*met by*), $R_{\overline{O}}$ (*overlapped by*), $R_{\overline{E}}$ (*ended by*), $R_{\overline{D}}$ (*contains*), $R_{\overline{B}}$ (*begun by*). These $13$ relations (including the *equality*) are mutually exclusive and jointly exhaustive, meaning that exactly one Allen's relation holds between any given pair of strict intervals.

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <img class="img-fluid rounded z-depth-1" src="{{ site.baseurl }}/assets/img/blog/2020/temporal-logics/HS.png">
    </div>
</div>

<div class="caption">
    HS modalities and Allen's Relations.
</div>

The $\mathsf{HS}$ syntax is based on:

* logical connectives: $\bot, \top, \neg, \land, \lor, \to$;
* unary *modal operators*: $\langle X \rangle, [X], \langle \overline{X} \rangle, [\overline{X}]$;
* a set $\mathcal{AP}$ of *atomic propositions*: $p,q,r,t,\ldots$;

where, for each $X \in \\{L,A,O,E,D,B\\}$, $\langle X \rangle$ is an *existential* interval modality according to those in the previous figure, and its dual *universal* modality is defined as $[X] \equiv \neg \langle X \rangle \neg$.

Well formed formulas are generated by the following grammar:

$$\varphi ::= p \mid \neg \varphi \mid \varphi \lor \varphi \mid \langle X \rangle \varphi \mid \langle \overline{X} \rangle \varphi.$$

The remaining connectives are derived as before.

Formulas are interpreted on *interval models* $M = \langle \mathbb{I}(\mathbb{D}), V \rangle$, where $V : \mathcal{AP} \to 2^{\mathbb{I}(\mathbb{D})}$ is a valuation function that associates to every proposition letter $p \in \mathcal{AP}$ the set of intervals $V(p)$ on which $p$ holds. Moreover, to stress the fact that $\mathsf{HS}$ is an extended version of $\mathsf{ML}$, following the same notation from $\mathsf{ML}$, we should define models as $M = \langle \mathbb{I}(\mathbb{D}),R_L,R_{\overline{L}},R_A,R_{\overline{A}},\ldots,V \rangle$, but the relations $R_X$ and $R_{\overline{X}}$, where $X \in \\{L,A,O,E,D,B\\}$, of $\mathsf{HS}$ are implied by the relation $<$. The satisfiability relation is defined as:

* $M,[x,y] \models p$ iff $[x,y] \in V(p)$, $\forall p \in \mathcal{AP}$;
* $M,[x,y] \models \neg \varphi$ iff $M,[x,y] \not\models \varphi$;
* $M,[x,y] \models \varphi_1 \lor \varphi_2$ iff $M,[x,y] \models \varphi_1$ or $M,[x,y] \models \varphi_2$;
* $M,[x,y] \models \langle X \rangle \varphi$ iff exists an interval $[z,t]$ such that $[x,y]R_X[z,t]$ and $M,[z,t] \models \varphi$;
* $M,[x,y] \models \langle \overline{X} \rangle \varphi$ iff exists an interval $[z,t]$ such that $[x,y]R_{\overline{X}}[z,t]$ and $M,[z,t] \models \varphi$;

where $X \in \\{L,A,O,E,D,B\\}$. To give an example, we can define the semantics of the during relation as:

* $M,[x,y] \models \langle D \rangle \varphi$ iff $M,[z,t]$ for some $[z,t]$ such that $x < z < t < y$.

Like $\mathsf{FOL}$, the SAT problem for HS is undecidable. A diffrence between $\mathsf{FOL}$ and $\mathsf{HS}$ is that it is natural to investigate on reasonable auto-contained fragments with better computational properties from the practical point of view. It turns out that $\mathsf{HS}$ is more expressive than $\mathsf{LTL}$:

$$\mathsf{PL} \prec \mathsf{ML} \prec \mathsf{LTL} \prec \mathsf{HS} \prec \mathsf{FOL}.$$

Following the same terminology from $\mathsf{HS}$, in order to define the semantics of a new, less expressive logic, called $\mathsf{HS}_3$, we introduce a new relation, which we call *intersect*. In general, given any subset $S \subseteq \\{ X, \overline{X} \mid X \in \\{L,A,O,E,D,B\\}\\}$, one can define the relation:

$$R_S = \bigvee_{X \in S} R_X \lor \bigvee_{\overline{X} \in S} R_{\overline{X}}.$$

Therefore, the relation intersect is defined as:

$$I = A \lor \overline{A} \lor O \lor \overline{O} \lor E \lor \overline{E} \lor D \lor \overline{D} \lor B \lor \overline{B}.$$ 

Well formed $\mathsf{HS}_3$ formulas can be recursively derived from the same $\mathsf{HS}$ grammar when $X \in \\{L,I\\}$. The semantics of $\mathsf{HS}_3$ are defined similarly to those of $\mathsf{HS}$ with respect to the relation intersect.

Two important results have been proven in <d-cite key="MUNOZVELASCO20191"></d-cite>. On the one hand, given a finitely satisfiable formula $\varphi$ in $\mathsf{HS}_3$, then it is satisfied on a model $M = \langle \mathbb{I}(\mathbb{D}), V \rangle$ whose domain $\mathbb{D}$ cardinality is bounded by:

$$\\|\varphi\\| \cdot 2^{\\|\varphi\\| \cdot \mathrm{log}(\\|\varphi\\|)} \cdot 2^{\\|\varphi\\|^2 \cdot \mathrm{log}(4 \cdot \\|\varphi\\| + 1)} \cdot 2^{\\|\varphi\\|^2} = 2^{O(\\|\varphi\\|^3)}.$$

On the other hand, the SAT problem for $\mathsf{HS}_3$ in the finite case, in the case of natural numbers, in the case of the integers, and in the case of discrete liner orders is $PSpace$-complete. Before concluding, we add the last piece to our "puzzle":

$$\mathsf{PL} \prec \mathsf{ML} \prec \mathsf{LTL} \prec \mathsf{HS}_3 \prec \mathsf{HS} \prec \mathsf{FOL}.$$

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <img class="img-fluid rounded z-depth-1" src="{{ site.baseurl }}/assets/img/blog/2020/temporal-logics/logics.png">
    </div>
</div>

<div class="caption">
    Representation of the presented logics.
</div>

## Conclusions

In this presentation, we have made a journey through some of the (classical and non-classical) logics used in Artificial Intelligence focusing on their SAT problem. Some of these logics are well-known in the literature (e.g., $\mathsf{PL}$, $\mathsf{LTL}$), but others, such as $\mathsf{HS}$, are less studied. One of the goals of this presentation was to give a quick overview of some of these logics without going to deep with the mathematical details.

The satisfiability problem of logics is among the most studied problems in theoretical computer science. Another well-studied problem is the *Model Checking* (MC, for short) problem and a great effort has been made in the last decades in addressing such problem, which is beyond the scope of this presentation. The reader can refer to <d-cite key="Clarke:2000:MC:332656"></d-cite> for a systematic and organic presentation of the MC problem.














